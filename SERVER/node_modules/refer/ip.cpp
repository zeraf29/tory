 // TestLocalIpAddress.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
 //
 
 //#include "stdafx.h"
 
 #include <stdio.h>
 
 #ifdef WIN32
 #include <winsock2.h>
 #else
 #include <unistd.h>
 #include <netdb.h>
 #include <string.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <sys/ioctl.h>
 #include <net/if.h>
 #endif
 
 int main( int argc, char * argv[] )
 {
 #ifdef WIN32
   // 로컬 호스트 이름을 구한다.
   char szHostName[128] = "";
   struct sockaddr_in SocketAddress;
   struct hostent     *pHost        = 0;
   char  szIpAddress[16];
 
   WORD wVersionRequested = MAKEWORD( 2, 2 );
   WSADATA wsaData;
   int err;
 
   err = WSAStartup( wVersionRequested, &wsaData );
   if( err != 0 ) return 0;
 
   if( LOBYTE( wsaData.wVersion ) != 2 || HIBYTE( wsaData.wVersion ) != 2 ) 
   {
     WSACleanup();
     return 0;
   }
 
   if( gethostname(szHostName, sizeof(szHostName)) )
   {
     return false;
   }
 
   // 로컬 호스트의 IP 주소를 구한다.
   pHost = gethostbyname(szHostName);
   if(!pHost) return false;
   
   for( int i = 0; pHost->h_addr_list[i]; i++ )
   {
     memcpy( &SocketAddress.sin_addr, pHost->h_addr_list[i], pHost->h_length);
     strcpy( szIpAddress, inet_ntoa(SocketAddress.sin_addr) );
     if( strcmp( szIpAddress, "127.0.0.1" ) )
     {
       printf( "[%s]\n", szIpAddress );
     }
   }
 
   WSACleanup();
 #else
   struct ifconf ifc;
   
   int s = socket( AF_INET, SOCK_DGRAM, 0 );
   int len = 100 * sizeof(struct ifreq);
   
   char buf[ len ];
   
   ifc.ifc_len = len;
   ifc.ifc_buf = buf;
   
   int e = ioctl(s,SIOCGIFCONF,&ifc);
   char *ptr = buf;
   int tl = ifc.ifc_len;
   char  szIp[16];
   
   while ( tl > 0 )
   {
     struct ifreq* ifr = (struct ifreq *)ptr;
     int si;
     
 #ifdef __linux__
     // 리눅스에서 실행되기 위한 코드
     si = sizeof(ifr->ifr_name) + sizeof(struct sockaddr);
 #else
     // MAC OS-X 에서 실행되기 위한 코드
     if( ifr->ifr_addr.sa_len > sizeof(struct sockaddr) )
     {
       si = sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
     }
     else
     {
       si = sizeof(ifr->ifr_name) + sizeof(struct sockaddr);
     }
 #endif
 
     tl -= si;
     ptr += si;
     
     struct ifreq ifr2;
     ifr2 = *ifr;
     
     e = ioctl(s,SIOCGIFADDR,&ifr2);
     if( e == -1 )
     {
        continue;
     }
     
     struct sockaddr a = ifr2.ifr_addr;
     struct sockaddr_in* addr = (struct sockaddr_in*) &a;
     
     unsigned int ai = ntohl( addr->sin_addr.s_addr );
     // 127.0.0.1 주소는 출력하지 않는다.
     if( int((ai>>24)&0xFF) == 127 ) continue;
 
     snprintf( szIp, sizeof(szIp), "%d.%d.%d.%d", int((ai>>24)&0xFF)
       , int((ai>>16)&0xFF)
       , int((ai>> 8)&0xFF) 
       , int((ai    )&0xFF) );
     printf( "[%s]this\n", szIp );
   }
   
   close(s);
 #endif
 
   return 0;
 }


